#!/usr/bin/env lua

--[[
===============================================================================
Require adjustment script for LuaRocks-based Factorio projects.

This script:
1) Parses the given rockspec file and checks dependencies:
   - Checks the Lua version requirement and halts if unmet.
   - Runs "luarocks install --deps-only <rockspec>" in the projectâ€™s root folder
     so that all dependencies are installed in lua_modules.
2) Loads the LuaRocks manifest from "lua_modules/lib/luarocks/rocks-<lua_version>/manifest".
3) Recursively resolves dependencies from the manifest, building a table of
   package metadata (modules, source_url, description).
4) Creates or overwrites "lua_modules.lua" with:
   - An autogenerated file warning.
   - A short package overview in a README-friendly format.
   - A custom require override that redirects modules that live in lua_modules
     to their correct installed location, while leaving normal requires intact.

===============================================================================
--]]

--#region Make sure this script is not run from inside of Factorio

-- Factorio runs on Lua 5.2
-- `.pack`, `.packsize` and `.unpack` were added to the string library in Lua 5.4.6.
-- Wube backported them to the Lua 5.2 based Lua engine used in Factorio.
-- They also added the following, available during both prototype and runtime stage:
--  - The serpent library
--  - The global functions `log()` and `table_size()`
--  - The global tables `settings` and `defines`
if _VERSION == "Lua 5.2" and serpent and log and table_size and settings and defines then
    error("ðŸš¨ This script is not intended to be run inside Factorio.")
end

--#endregion Make sure this is not run inside of Factorio

--#region Setup utilities

local lua_version = _VERSION:match("Lua (.*)")

--#region File system

-- NOTE: All functions in this section take relative paths as arguments.

local path_separator = package.config:sub(1, 1) ---@diagnostic disable-line:undefined-field
local on_windows = path_separator == "\\" ---@diagnostic disable-line:undefined-field
local current_directory ---@type string
-- Get the absolute path of the current directory
if on_windows then
    local handle = io.popen("cd") ---@diagnostic disable-line:undefined-global
    -- The previous command should always have succeed, casting to satisfy diagnostics
    ---@cast handle -nil
    current_directory = handle:read("*l")
    handle:close()
else
    local handle = io.popen("pwd") ---@diagnostic disable-line:undefined-global
    -- The previous command should always have succeed, casting to satisfy diagnostics
    ---@cast handle -nil
    current_directory = handle:read("*l")
    handle:close()
end

---Combines multiple paths into a single path.
---@vararg string The paths to combine.
---@return string combined_path The combined path.
local function join_paths(...)
    local paths = { ... }
    local combined_path = paths[1]

    for i = 2, #paths do
        if not (combined_path:sub(-1) == path_separator) and not (paths[i]:sub(1) == path_separator) then
            combined_path = combined_path .. path_separator .. paths[i]
        elseif (combined_path:sub(-1) == path_separator) and (paths[i]:sub(1) == path_separator) then
            combined_path = combined_path .. paths[i]:sub(2)
        else
            combined_path = combined_path .. paths[i]
        end
    end

    return combined_path
end

---Returns the absolute path for a relative path.
---@param path string The relative path.
---@return string absolute_path The absolute path.
local function absolute_path(path)
    return join_paths(current_directory, path)
end

---Checks whether a path is an existing file.
---@param path string The path to check.
---@return boolean path_is_file True if the path is a file, false otherwise.
local function is_file(path)
    -- Assert path is not nil or an empty string
    if not path or path == "" then
        error("ðŸš¨ Parameter 'path' is nil or an empty string.")
    end

    path = absolute_path(path)

    local command ---@type string
    if on_windows then
        command = 'if exist "' .. path .. '" (echo file) else (echo not)'
    else
        command = 'test -f "' .. path .. '" && echo file || echo not'
    end

    local handle = io.popen(command) ---@diagnostic disable-line:undefined-global
    -- The previous command should always have succeed, casting to satisfy diagnostics
    ---@cast handle -nil
    local result = handle:read("*all")
    handle:close()

    return result:find("file") ~= nil
end

---Gets a list of files and directories in a directory.
---@param path string The path to list.
---@return string[] entries The list of entries in the directory.
local function list_dir(path)
    -- Assert path is not nil or an empty string
    if not path or path == "" then
        error("ðŸš¨ Parameter 'path' is nil or an empty string.")
    end

    path = absolute_path(path)

    local entries = {}

    local command
    if on_windows then
        command = 'dir "' .. path .. '" /b'
    else
        command = 'ls "' .. path .. '"'
    end

    local handle = io.popen(command) ---@diagnostic disable-line:undefined-global
    -- The previous command should always have succeed, casting to satisfy diagnostics
    ---@cast handle -nil
    for entry in handle:lines() do
        table.insert(entries, entry)
    end
    handle:close()
    return entries
end

---Reads the contents of a file.
---@param path string The path to the file.
---@return string content The contents of the file
local function read_file(path)
    -- Assert path is not nil or an empty string
    if not path or path == "" then
        error("ðŸš¨ Parameter 'path' is nil or an empty string.")
    end

    path = absolute_path(path)

    local f, err = io.open(path, "r") ---@diagnostic disable-line:undefined-global
    if not f then
        error("ðŸš¨ Failed to open file for reading:\nFile path: '" .. path .. "'\n" .. err)
    end
    local content = f:read("*all")
    f:close()
    return content
end

---Writes content to a file.
---@param path string Path to the file.
---@param content string The content to write.
local function write_file(path, content)
    -- Assert path is not nil or an empty string
    if not path or path == "" then
        error("ðŸš¨ Parameter 'path' is nil or an empty string.")
    end

    path = absolute_path(path)

    local f, err = io.open(path, "w") ---@diagnostic disable-line:undefined-global
    if not f then
        error("ðŸš¨ Failed to open file for writing:\nFile path: '" .. path .. "'\n" .. err)
    end
    f:write(content)
    f:close()
    return true
end

--#endregion File system

--#region LuaRocks

--#region Rockspec Configuration

---Represents a rockspec configuration.
---@class RockspecConfiguration
---@field dependencies string[] The dependencies of the package
---@field description RockspecConfigurationDescription The description of the package
---@field source RockspecConfigurationSource The source of the package

---Represents a rockspec configuration description.
---@class RockspecConfigurationDescription
---@field license string The license of the package.
---@field summary string The summary of the package.
---@field detailed? string The detailed description of the package.
---@field homepage? string The URL to the homepage of the package.
---@field maintainer? string The maintainer of the package.

---Represents a rockspec configuration source.
---@class RockspecConfigurationSource
---@field url string The URL to the source repository.

---Loads a LuaRocks file as a table with its configurations as fields.
---@param path string The path to the LuaRocks file.
---@return table<string, any> luarocks_configurations The loaded LuaRocks file as a table.
local function load_luarocks_file(path)
    -- Check if path points to a file
    if not is_file(path) then
        error("ðŸš¨ Parameter 'path' does not point to a file.\nProvided path: '" .. tostring(path) .. "'\n")
    end

    path = absolute_path(path)

    -- Container for the rockspec configuration
    local file_env = {}

    -- Safely load the rockspec
    local file_chunk, err = loadfile(path, "t", file_env)
    if not file_chunk then
        error("ðŸš¨ Failed to load LuaRocks file: " .. err .. "\nProvided path: '" .. tostring(path) .. "'\n")
    end

    -- Execute the chunk in the specified environment
    local success, result = pcall(file_chunk)
    if not success then
        error("ðŸš¨ Error executing LuaRocks file: " .. tostring(result) .. "\nProvided path: '" .. tostring(path) .. "'\n")
    end

    return file_env
end

---Loads a rockspec file as a table with its configurations as fields.
---@param path string The path to the rockspec file.
---@return RockspecConfiguration rockspec_config The loaded rockspec file as a table.
local function load_rockspec(path)
    -- Container for the rockspec configuration
    local rockspec_env = load_luarocks_file(path) ---@type RockspecConfiguration

    -- Verify the rockspec configuration satisfies the required fields

    --#region Verify dependencies
    if type(rockspec_env.dependencies) ~= "table" then
        error("ðŸš¨ Rockspec 'dependencies' field is missing or not a table.")
    end
    --#endregion Verify dependencies

    --#region Verify description
    if type(rockspec_env.description) ~= "table" then
        error("ðŸš¨ Rockspec 'description' field is missing or not a table.")
    end
    local description = rockspec_env.description
    if type(description.license) ~= "string" or description.license == "" then
        error("ðŸš¨ Rockspec 'description.license' field is missing or not a string.")
    end
    if type(description.summary) ~= "string" or description.summary == "" then
        error("ðŸš¨ Rockspec 'description.summary' field is missing or not a string.")
    end
    --#endregion Verify description

    --#region Verify source
    if type(rockspec_env.source) ~= "table" then
        error("ðŸš¨ Rockspec 'source' field is missing or not a table.")
    end
    if type(rockspec_env.source.url) ~= "string" then
        error("ðŸš¨ Rockspec 'source.url' field is missing or not a string.")
    end
    --#endregion Verify source

    return rockspec_env
end

--#endregion Rockspec Configuration

--#region Manifest Configuration

---Represents a LuaRocks manifest.
---@class ManifestConfiguration
---@field repository table<string, table<string, ManifestRepositoryPackageVersionConfiguration[]>> The repository entries.

---Represents a LuaRocks manifest repository package version information.
---@class ManifestRepositoryPackageVersionConfiguration
---@field dependencies table<string, string> The dependencies of the package.
---@field modules table<string, string> The modules of the package.

---Loads a LuaRocks manifest file as a table with its configurations as fields.
---@param path string The path to the manifest file.
---@return ManifestConfiguration manifest_config The loaded manifest file as a table.
local function load_manifest(path)
    -- Container for the manifest configuration
    local manifest_env = load_luarocks_file(path)

    -- Verify the manifest configuration satisfies the required fields
    ---@cast manifest_env ManifestConfiguration

    --#region Verify repository
    if type(manifest_env.repository) ~= "table" then
        error("ðŸš¨ Manifest 'repository' field is missing or not a table.")
    end
    --#endregion Verify repository

    return manifest_env
end

--#endregion Manifest Configuration

--#endregion LuaRocks

--#endregion Setup utilities

--#region Load the mod's info.json file into mod_info

-- Make sure info.json exists in the current directory
if not is_file("info.json") then
    error("ðŸš¨ info.json file not found:\n" .. current_directory ..
        "\nMake sure to run the script in the mod's root directory.")
end

-- Convert info.json file content into a lua executable string
local info_json = read_file("info.json")
local info_lua_code = "return " .. info_json
    :gsub('"([%a_][%w_]*)":', '%1 =') -- Remove quotes around valid keys
    :gsub('%[', '{')
    :gsub('%]', '}')

-- Compile and execute the converted lua code
local info_func, err = load(info_lua_code, "info.json", "t", {})
if not info_func then
    error("ðŸš¨ Failed to load info.json as Lua table: " .. err ..
        "\nFully transformed code:\n" .. info_lua_code .. "\n")
end
local mod_info = info_func()

--#endregion Load the mod's info.json file into mod_info

-- Print some information about the environment
print()
print("Using Lua version:", lua_version)
print("Current directory:", current_directory)
print("Mod identifier:", "", mod_info.name)
print("Mod version:", "", mod_info.version)
print()

-- As Factorio runs with Lua 5.2, for simplicity we will only support Lua 5.2 for now
if lua_version ~= "5.2" then
    error("ðŸš¨ This script is intended to be run with Lua 5.2. Detected version: " .. lua_version)
end

--#region Load the mod's rockspec file

-- Construct the mod's current versions rockspec file path (assuming revision 0)
local mod_rockspec_path = mod_info.name .. "-" .. mod_info.version .. "-0.rockspec"

-- Make sure the rockspec file exists
if not is_file(mod_rockspec_path) then
    error("ðŸš¨ Rockspec file not found:\nExpected: " .. mod_rockspec_path ..
        "\nMake sure the file is in the mod's root directory and the name reflects the version set in info.json.\n")
end

-- Load and parse the rockspec file
local mod_rockspec_configuration = load_rockspec(mod_rockspec_path)

--#endregion Load the mod's rockspec file

--#region Install/update the mod's dependencies

-- Add the mod's dependencies to the mod_dependencies table
local mod_dependencies = {} ---@type table<string, boolean>
for _, dependency_string in ipairs(mod_rockspec_configuration.dependencies) do
    local dependency_name = dependency_string:match("^([%a_][%w_]*)") ---@type string?
    if not dependency_name then
        error(
            ("Dependency string does not start with a valid Lua identifier: '%s'")
            :format(dependency_string))
    end

    -- Add the dependency to the mod_dependencies table, excluding the Lua dependency
    if dependency_name ~= "lua" then
        mod_dependencies[dependency_name] = true
    end
end

-- If there mod has no dependencies, this script is not needed
if next(mod_dependencies) == nil then
    error([[ðŸš¨ No mod rockspec dependencies.

    No dependencies defined in the rockspec file (Lua does not count).
    Running this script is not required.
    ]])
end

-- Run the luarocks install command to install the dependencies
local cmd = "luarocks install --deps-only " .. mod_rockspec_path
print("Running: " .. cmd)
local ret_code = os.execute(cmd) ---@diagnostic disable-line: undefined-global
if not ret_code or ret_code == "fail" or (ret_code ~= 0 and ret_code ~= true) then
    error("ðŸš¨ Failed to install dependencies via LuaRocks. Return code: " .. tostring(ret_code))
end

print("Done running luarocks install command.\n")

--#endregion Install/update the mod's dependencies

--#region Load the LuaRocks manifest

-- Manifest files are located at:
-- lua_modules/lib/luarocks/rocks-<major.minor>/manifest

-- Define the path to the LuaRocks repository parent directory
local repository_parent_path = join_paths("lua_modules", "lib", "luarocks")

-- Make sure exactly one repository exists
local repository_paths = list_dir(repository_parent_path)
if #repository_paths == 0 then
    error("ðŸš¨ No repositories found in the LuaRocks directory.")
elseif repository_paths[2] then
    error([[ðŸš¨ Multiple repositoires not supported:

    Multiple repositories were found in the LuaRocks directory.

    Even though LuaRocks allows multiple repositories for multiple Lua versions
    to be installed at the same time, this script does not support that. All repositories
    would be loaded into the Factorio mod, which is likely not what you want. Also supporting
    LuaRocks in Factorio would become way more complex.

    Please ensure that only one repository is installed into the mod.]])
end

-- Load and parse the repository's manifest file
local manifest_config = load_manifest(
    join_paths(
        repository_parent_path,
        repository_paths[1],
        "manifest"))

--#endregion Load the LuaRocks manifest

--#region Load all mod dependencies rockspecs and build module redirects

local loaded_rockspecs = {} ---@type table<string, RockspecConfiguration>
local module_redirects = {} ---@type table<string, string>

---Processes a dependency and its sub-dependencies.
---@param dependency_name string The name of the dependency to process.
local function process_dependency(dependency_name)
    -- Skip if the dependency has already been processed
    if loaded_rockspecs[dependency_name] then return end

    print("Processing dependency:", dependency_name)

    --#region Make sure the dependency is valid and fetch the correct package_configuration

    -- Make sure the dependency exists in the manifest
    local dependency = manifest_config.repository[dependency_name]
    if not dependency then
        error([[ðŸš¨ Dependency not found:

    The package ']] .. dependency_name .. [[' was not found in the LuaRocks
    repository manifest.

    Please make sure the dependency has been installed.]])
    end

    -- Make sure there is only one version of the package in the manifest
    local dependency_versions = {} ---@type string[]
    for version, _ in pairs(dependency) do
        table.insert(dependency_versions, version)
    end
    if dependency_versions[2] then
        error([[ðŸš¨ Not supported:

    Multiple versions of package ']] .. dependency_name .. [[' found in the LuaRocks
    repository manifest.

    Even though LuaRocks allows multiple versions of a package to be installed at the
    same time, this script does not support that. All versions would be loaded into
    the Factorio mod simultaneously, which is likely not what you want. Also supporting
    LuaRocks in Factorio would become way more complex.

    Please ensure that only one version of the package is installed.]])
    end

    -- Make sure there is only one configuration for the package version
    if dependency[dependency_versions[1]][2] then
        error([[ðŸš¨ Not supported:

        Multiple configurations for version ']] .. dependency_versions[1] .. [[' of
        package ']] .. dependency_name .. [[' found in the LuaRocks repository manifest.

        Even though LuaRocks allows multiple configurations of a package to be installed at the
        same time, this script does not support that. All configurations would be loaded into
        the Factorio mod simultaneously, which is likely not what you want. Also supporting
        LuaRocks in Factorio would become way more complex.

        Please ensure that only one version of the package is installed.]])
    end

    local package_configuration = dependency[dependency_versions[1]][1]

    --#endregion Make sure the package is valid and fetch the correct package_configuration

    -- Add the dependency's rockspec to the loaded rockspecs
    local rockspec_path = join_paths(
        "lua_modules", "lib", "luarocks", "rocks-" .. lua_version,       -- repository path
        dependency_name, dependency_versions[1],                         -- package path
        dependency_name .. "-" .. dependency_versions[1] .. ".rockspec") -- rockspec file
    loaded_rockspecs[dependency_name] = load_rockspec(rockspec_path)

    -- Add the dependency's modules to the redirects
    for module_name, module_path in pairs(package_configuration.modules) do
        -- Assert module name equals module path (without .lua and / replaced by .)
        local module_path_without_extension = module_path:match("^(.-)%.lua$") ---@type string?
        if not module_path_without_extension then
            error("ðŸš¨ Module path does not end with '.lua': " .. module_path)
        end
        local expected_module_name = module_path_without_extension:gsub("/", ".")
        if module_name ~= expected_module_name then
            error("ðŸš¨ Module name does not match module path: " .. module_name .. " ~= " .. expected_module_name)
        end

        -- Add the module to the module redirects
        module_redirects[module_name] = module_path

        -- If module name ends with ".init", also add the shortened version
        if module_name:match("%.init$") then
            local shorter_name = module_name:gsub("%.init$", "")
            module_redirects[shorter_name] = module_path
        end
    end

    -- Recursively process the sub-dependencies
    for sub_dependency_name, _ in pairs(package_configuration.dependencies) do
        process_dependency(sub_dependency_name)
    end
end

-- Process the mod's dependencies recursively
for dependency_name, _ in pairs(mod_dependencies) do
    process_dependency(dependency_name)
end

--#endregion Load all mod dependencies rockspecs and build module redirects

--#region Generate the "lua_modules.lua" file

local lines = {}

-- Add a warning to the top of the file
table.insert(lines, "-- This file is autogenerated by a script.")
table.insert(lines, "-- DO NOT EDIT; any changes may be overwritten.")
table.insert(lines, "")

-- Add a summary of the used packages and their sources
table.insert(lines, "--[[")
table.insert(lines, "")
table.insert(lines, "Below is a summary of used packages and their sources.")
table.insert(lines, "You can copy this section into your README or simly link to this file.")
table.insert(lines, "")
table.insert(lines, "# Third-Party Libraries and Dependencies")

-- Sort the package names for consistent output
local package_names = {} ---@type string[]
for package_name, _ in pairs(loaded_rockspecs) do
    table.insert(package_names, package_name)
end
table.sort(package_names)

-- Add the package information to the file
for _, package_name in ipairs(package_names) do
    local rockspec_config = loaded_rockspecs[package_name]

    local summary = rockspec_config.description.summary
    local license = rockspec_config.description.license
    local details = rockspec_config.description.detailed
    local homepage = rockspec_config.description.homepage
    local source_url = rockspec_config.source.url

    -- For source_url, support only git+http for now
    if source_url:match("^git%+http") then
        -- Remove the "git+" prefix, and the .git suffix if it exists
        source_url = source_url:sub(5)
        source_url = source_url:gsub("%.git$", "")
    else
        error("ðŸš¨ Unsupported source URL scheme: " .. source_url)
    end

    table.insert(lines, ("\n## %s"):format(package_name))
    table.insert(lines, "")
    table.insert(lines, ("Summary: %s"):format(summary))
    table.insert(lines, "")
    if details and details ~= "" then
        -- If details ends with just a line of whitespace, remove it
        details = details:gsub("\n%s*$", "")

        table.insert(lines, ("Details:\n%s"):format(details))
        table.insert(lines, "")
    else
        print(("WARNING: Package '%s' has no 'detailed' description."):format(package_name))
    end

    table.insert(lines, ("License: %s"):format(license))

    if homepage and homepage ~= "" then
        table.insert(lines, ("Homepage: <%s>"):format(homepage))
    else
        print(("WARNING: Package '%s' has no 'homepage'."):format(package_name))
    end

    if source_url and source_url ~= "" then
        table.insert(lines, ("Source: <%s>"):format(source_url))
    else
        print(("WARNING: Package '%s' has no 'source.url'"):format(package_name))
    end
end

table.insert(lines, "\n--]]\n")

-- Detect the path separator for the current platform
table.insert(lines, [[
local path_separator = "/"
if package.config then ---@diagnostic disable-line:undefined-field
    path_separator = package.config:sub(1, 1) ---@diagnostic disable-line:undefined-field
end
]])

-- Build the module redirect prefix
table.insert(lines, [[
local redirect_prefix_parts = {
    "lua_modules",
    "share",
    "lua",
    "]] .. lua_version .. [[" .. path_separator
}
local redirect_prefix = table.concat(redirect_prefix_parts, path_separator)
]])

-- Check if the Lua version is 5.2 and if the Factorio global variables are available
-- If so, generate the module redirects and require override
table.insert(lines, [[
if _VERSION == "Lua 5.2" and serpent and log and table_size and settings and defines then
    -- Factorio, supports '.' in package names (does not replace)

    local redirection = {]])

-- Sort the module redirects for consistent output
local redirect_lines = {} ---@type string[]
for module_name, module_target_path in pairs(module_redirects) do
    table.insert(redirect_lines,
        ('        ["%s"] = redirect_prefix .. "%s",'):format(module_name, module_target_path))
end
table.sort(redirect_lines)

-- Fill the redirection table for the require override
for _, line in ipairs(redirect_lines) do
    table.insert(lines, line)
end
table.insert(lines, "    }")

-- Still Factorio, replace require
table.insert(lines, [=[

    local original_require = require
    require = function(module_name)
        if redirection[module_name] then
            log([[Redirecting require.
            From: ]] .. module_name .. [[
            To: ]] .. redirection[module_name])
        end

        return original_require(redirection[module_name] or module_name)
    end]=])

-- Not Factorio anymore, else branch for desktop environment
table.insert(lines, [[
else
    -- Windows, macOS or Linux, replaces '.' in package names, but supports extending package.path

    local path_extension_parts = {
        "%s;%s",
        "?.lua;%s",
        "?",
        "init.lua"
    }
    local path_extension = table.concat(path_extension_parts, path_separator)

    package.path = (path_extension):format(
        package.path, redirect_prefix, redirect_prefix)
end
]])

-- Write the prepared lines to the file
local success, werr = write_file("lua_modules.lua", table.concat(lines, "\n"))
if not success then
    error("ðŸš¨ Failed to write lua_modules.lua: " .. tostring(werr))
end

print("\nâœ… lua_modules.lua successfully created/updated!")

--#endregion Generate the "lua_modules.lua" file
